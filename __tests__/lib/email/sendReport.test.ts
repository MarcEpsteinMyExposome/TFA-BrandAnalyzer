import {
  createMockBrandReport,
  createMockPlatformEntry,
} from '@/lib/testing/mockData'
import { sendReportEmail, formatReportEmail } from '@/lib/email/sendReport'
import type { BrandReport } from '@/lib/schemas/report.schema'
import type { PlatformEntry } from '@/lib/schemas/platform.schema'

describe('sendReport', () => {
  const originalEnv = process.env
  const originalFetch = global.fetch

  let mockReport: BrandReport
  let mockPlatforms: PlatformEntry[]

  beforeEach(() => {
    process.env = { ...originalEnv }
    process.env.NEXT_PUBLIC_FORMSPREE_URL = 'https://formspree.io/f/testform'

    mockReport = createMockBrandReport()
    mockPlatforms = [
      createMockPlatformEntry({
        platform: 'website',
        url: 'https://janeartist.com',
      }),
      createMockPlatformEntry({
        platform: 'instagram',
        url: 'https://instagram.com/janeartist',
      }),
      createMockPlatformEntry({
        platform: 'etsy',
        url: 'https://etsy.com/shop/janeartist',
      }),
    ]

    global.fetch = jest.fn()
  })

  afterEach(() => {
    process.env = originalEnv
    global.fetch = originalFetch
  })

  describe('formatReportEmail', () => {
    it('includes the summary in the message', () => {
      const message = formatReportEmail(mockReport, mockPlatforms)
      expect(message).toContain(mockReport.summary)
    })

    it('includes consistency score', () => {
      const message = formatReportEmail(mockReport, mockPlatforms)
      expect(message).toContain(
        `CONSISTENCY SCORE: ${mockReport.consistency.overallScore}/100`
      )
    })

    it('includes completeness score', () => {
      const message = formatReportEmail(mockReport, mockPlatforms)
      expect(message).toContain(
        `COMPLETENESS SCORE: ${mockReport.completeness.overallScore}/100`
      )
    })

    it('includes top mismatches', () => {
      const message = formatReportEmail(mockReport, mockPlatforms)
      for (const mismatch of mockReport.consistency.mismatches) {
        expect(message).toContain(mismatch.description)
        expect(message).toContain(mismatch.recommendation)
      }
    })

    it('includes top gaps', () => {
      const message = formatReportEmail(mockReport, mockPlatforms)
      for (const gap of mockReport.completeness.gaps) {
        expect(message).toContain(gap.description)
        expect(message).toContain(gap.recommendation)
      }
    })

    it('includes action items', () => {
      const message = formatReportEmail(mockReport, mockPlatforms)
      for (const item of mockReport.actionItems) {
        expect(message).toContain(item.action)
        expect(message).toContain(item.platform)
      }
    })

    it('includes platform URLs', () => {
      const message = formatReportEmail(mockReport, mockPlatforms)
      for (const platform of mockPlatforms) {
        expect(message).toContain(platform.url)
        expect(message).toContain(platform.platform)
      }
    })

    it('includes header and footer', () => {
      const message = formatReportEmail(mockReport, mockPlatforms)
      expect(message).toContain('BRAND HEALTH REPORT')
      expect(message).toContain(
        'Generated by Tech For Artists - Brand Health Analyzer'
      )
    })
  })

  describe('sendReportEmail', () => {
    it('returns error when NEXT_PUBLIC_FORMSPREE_URL is not set', async () => {
      delete process.env.NEXT_PUBLIC_FORMSPREE_URL

      const result = await sendReportEmail(mockReport, mockPlatforms)

      expect(result.success).toBe(false)
      expect(result.error).toBe('NEXT_PUBLIC_FORMSPREE_URL is not configured')
      expect(global.fetch).not.toHaveBeenCalled()
    })

    it('sends correct payload to Formspree URL', async () => {
      ;(global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: async () => ({ ok: true }),
      })

      await sendReportEmail(mockReport, mockPlatforms)

      expect(global.fetch).toHaveBeenCalledTimes(1)
      const [url, options] = (global.fetch as jest.Mock).mock.calls[0]
      expect(url).toBe('https://formspree.io/f/testform')
      expect(options.method).toBe('POST')
      expect(options.headers['Content-Type']).toBe('application/json')
      expect(options.headers['Accept']).toBe('application/json')

      const body = JSON.parse(options.body)
      expect(body._replyto).toBe('noreply@technologyforartists.com')
      expect(body.name).toBe('Brand Analyzer')
      expect(body._subject).toMatch(/^Brand Health Report - /)
      expect(body.message).toContain(mockReport.summary)
      expect(body.message).toContain(
        String(mockReport.consistency.overallScore)
      )
      expect(body.message).toContain(
        String(mockReport.completeness.overallScore)
      )
    })

    it('includes _gotcha honeypot field as empty string', async () => {
      ;(global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: async () => ({ ok: true }),
      })

      await sendReportEmail(mockReport, mockPlatforms)

      const body = JSON.parse(
        (global.fetch as jest.Mock).mock.calls[0][1].body
      )
      expect(body._gotcha).toBe('')
    })

    it('returns success on 200 response', async () => {
      ;(global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: async () => ({ ok: true }),
      })

      const result = await sendReportEmail(mockReport, mockPlatforms)

      expect(result.success).toBe(true)
      expect(result.error).toBeUndefined()
    })

    it('returns error on failed response', async () => {
      ;(global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        status: 422,
      })

      const result = await sendReportEmail(mockReport, mockPlatforms)

      expect(result.success).toBe(false)
      expect(result.error).toBe('Formspree returned 422')
    })

    it('returns error on network failure', async () => {
      ;(global.fetch as jest.Mock).mockRejectedValue(
        new Error('Network error')
      )

      const result = await sendReportEmail(mockReport, mockPlatforms)

      expect(result.success).toBe(false)
      expect(result.error).toBe('Network error')
    })

    it('includes subject line with date', async () => {
      ;(global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: async () => ({ ok: true }),
      })

      await sendReportEmail(mockReport, mockPlatforms)

      const body = JSON.parse(
        (global.fetch as jest.Mock).mock.calls[0][1].body
      )
      // Subject should contain "Brand Health Report - " followed by a date string
      expect(body._subject).toMatch(/^Brand Health Report - \w+ \d+, \d{4}$/)
    })
  })
})
