import type { BrandReport } from '@/lib/schemas/report.schema'
import type { PlatformEntry } from '@/lib/schemas/platform.schema'

interface SendReportResult {
  success: boolean
  error?: string
}

function formatDate(): string {
  return new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  })
}

function formatReportEmail(
  report: BrandReport,
  platforms: PlatformEntry[]
): string {
  const lines: string[] = []

  // Summary
  lines.push('BRAND HEALTH REPORT')
  lines.push('='.repeat(40))
  lines.push('')
  lines.push('Summary:')
  lines.push(report.summary)
  lines.push('')

  // Consistency
  lines.push('CONSISTENCY SCORE: ' + report.consistency.overallScore + '/100')
  lines.push('-'.repeat(40))
  if (report.consistency.mismatches.length > 0) {
    lines.push('')
    lines.push('Top Mismatches:')
    const topMismatches = report.consistency.mismatches.slice(0, 5)
    for (const mismatch of topMismatches) {
      lines.push(
        `  [${mismatch.severity.toUpperCase()}] ${mismatch.description}`
      )
      lines.push(`    Platforms: ${mismatch.platforms.join(', ')}`)
      lines.push(`    Fix: ${mismatch.recommendation}`)
    }
  }
  lines.push('')

  // Completeness
  lines.push(
    'COMPLETENESS SCORE: ' + report.completeness.overallScore + '/100'
  )
  lines.push('-'.repeat(40))
  if (report.completeness.gaps.length > 0) {
    lines.push('')
    lines.push('Top Gaps:')
    const topGaps = report.completeness.gaps.slice(0, 5)
    for (const gap of topGaps) {
      lines.push(`  [${gap.severity.toUpperCase()}] ${gap.description}`)
      lines.push(`    Platforms: ${gap.platforms.join(', ')}`)
      lines.push(`    Fix: ${gap.recommendation}`)
    }
  }
  lines.push('')

  // Action Items
  if (report.actionItems.length > 0) {
    lines.push('TOP ACTION ITEMS')
    lines.push('-'.repeat(40))
    const topActions = report.actionItems.slice(0, 5)
    for (const item of topActions) {
      lines.push(
        `  ${item.priority}. [${item.impact.toUpperCase()} impact, ${item.effort}] ${item.action}`
      )
      lines.push(`     Platform: ${item.platform}`)
    }
    lines.push('')
  }

  // Platforms analyzed
  lines.push('PLATFORMS ANALYZED')
  lines.push('-'.repeat(40))
  for (const entry of platforms) {
    lines.push(`  ${entry.platform}: ${entry.url}`)
  }
  lines.push('')
  lines.push('---')
  lines.push('Generated by Tech For Artists - Brand Health Analyzer')

  return lines.join('\n')
}

export async function sendReportEmail(
  report: BrandReport,
  platforms: PlatformEntry[]
): Promise<SendReportResult> {
  const formspreeUrl = process.env.NEXT_PUBLIC_FORMSPREE_URL

  if (!formspreeUrl) {
    return {
      success: false,
      error: 'NEXT_PUBLIC_FORMSPREE_URL is not configured',
    }
  }

  const date = formatDate()
  const subject = `Brand Health Report - ${date}`
  const message = formatReportEmail(report, platforms)

  try {
    const response = await fetch(formspreeUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      body: JSON.stringify({
        _replyto: 'noreply@technologyforartists.com',
        name: 'Brand Analyzer',
        _subject: subject,
        message,
        _gotcha: '',
      }),
    })

    if (!response.ok) {
      return {
        success: false,
        error: `Formspree returned ${response.status}`,
      }
    }

    return { success: true }
  } catch (err) {
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Failed to send email',
    }
  }
}

// Export for testing
export { formatReportEmail }
